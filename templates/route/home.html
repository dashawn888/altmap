<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="initial-scale=1.0, user-scalable=no"/>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
  <title>Google Maps JavaScript API v3 Example: Geocoding Simple</title>
  <link href="http://code.google.com/apis/maps/documentation/javascript/examples/default.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=false"></script>
  <script type="text/javascript" src="http://crypto-js.googlecode.com/files/2.5.3-crypto-sha1.js"></script>
  <script type="text/javascript">
    var geoResults = {};
    var geocoder;
    var map;
    function initialize() {
      geocoder = new google.maps.Geocoder();
      var latlng = new google.maps.LatLng(-34.397, 150.644);
      var myOptions = {
        zoom: 8,
        center: latlng,
        mapTypeId: google.maps.MapTypeId.ROADMAP
      }
      map = new google.maps.Map(document.getElementById("map_canvas"), myOptions);
    }

    function codeAddress(id) {
      var address = document.getElementById(id).value;
      geocoder.geocode( { 'address': address}, function(results, status) {
        if (status == google.maps.GeocoderStatus.OK) {
          map.setCenter(results[0].geometry.location);
          var marker = new google.maps.Marker({
              map: map,
              position: results[0].geometry.location
          });

          // store the results in the geoResults object
          geoResults[id] = results[0].geometry.location;
          doCalculation();

        } else {
          alert("Geocode was not successful for the following reason: " + status);
        }
      });
    }

    function popwindow() {
      var def=doCalculation();
      var def1= def[0];
      var def2 = def[1];
      alert(def1);
      alert(def2);
    }

    function buildRouteHash(cordinates) {
      var sorted_cordinates = sortCordinatesArray(cordinates);

      var hashable_string = "";
      for (var i = 0; i < sorted_cordinates.length; i++) {
        hashable_string +=
            "(" + sorted_cordinates[i][0] + "," + sorted_cordinates[i][1] + ")";
      }

      return Crypto.SHA1(hashable_string);
    }

    // Yes it's ugly.
    function sortCordinatesArray(cordinates) {
      var sorted_cordinates = [];
      var original_length = cordinates.length;

      for (var i = 0; i < original_length; i++) {
        var min_index = 0;
        for (var j = 0; j < cordinates.length; j++) {
          if (cordinates[min_index][0] > cordinates[j][0]) {
            min_index = j;
          } else if (cordinates[min_index][0] == cordinates[j][0]) {
            if (cordinates[min_index][1] > cordinates[j][1]) {
              min_index = j;
            }
          }
        }
        sorted_cordinates.push(cordinates.splice(min_index, 1)[0]);
      }

      return sorted_cordinates;
    }

    // buildRouteHash([[9.5, 23.3], [10.5, 54.3], [9.5, 3.3],
    //     [12.5, 12.3], [5.5, 9.3], [6.5, 452.3], [7.5, 45.3]]);

    // Get a random x value between the 2 points
    function randomBetween(x, y) {
      var larger = 0;
      var smaller = 0;

      if (x > y) {
        larger = x;
        smaller = y;
      } else {
        larger = y;
        smaller = x;
      }

      var delta = larger - smaller;

      var random_delta = Math.random() * delta;
      return larger - random_delta;
    }

    function addRandomWaypoint(p, q, deviation_range) {
      // Use slope intercept form to get equation
      // Then calculate the new_y.
      // y = mx + b
      // b = y - mx
      var line_slope = slope(p, q);
      var b = p[1] - line_slope * p[0];

      // Now put b back in the equation using new_x to get new_y.
      // y = mx + b
      var new_x = randomBetween(p[0], q[0]);
      var new_y = line_slope * new_x + b;

      // Now we need to get a perpendicular line of the equation going through
      // point new_x, new_y
      var inverted_line_slope = -1 * (1 / line_slope);
      b = new_y - inverted_line_slope * new_x;
      new_x = randomBetween(new_x, new_x + deviation_range * 2) - deviation_range;
      new_y = inverted_line_slope * new_x + b;

      return [new_x, new_y];
    }

    function slope(p, q) {
      var y = q[1] - p[1];
      var x = q[0] - p[0];

      return y / x;
    }

    // addRandomWaypoint([10, 10], [0, 0], 3);

    function distance(p, q) {
      var dx = p[0] - q[0];
      var dy = p[1] - q[1];

      return Math.sqrt(dx*dx + dy*dy);
    }

    function doCalculation() {
      if (typeof geoResults.address1 === "object"
          && typeof geoResults.address2 === "object") {
          return [geoResults.address1, geoResults.address2];
          // Yay.. do something now.
          // geoResults.address1 is a LatLng() object.
          // geoResults.address2 is a LatLng() object.
      }
    }
  </script>
</head>
<body onload="initialize()">
  <div>
    <input id="address1" type="textbox" value="" style=" width:800px;height:30px;font-size:10px;">
    <input type="button" value="Geocode" onclick="codeAddress('address1')">
  </div>
  <div>
   <input id="address2" type="textbox" value="" style=" width:800px;height:30px;font-size:10px;">
   <input type="button" value="Geocode" onclick="codeAddress('address2')">
  </div>
  <div>

<input type="button" onclick="popwindow()" value="Show alert box" />
  </div>
  <div id="map_canvas" style="height:90%;top:80px"></div>
</body>
</html> 
